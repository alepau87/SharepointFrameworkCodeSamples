"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lodash_1 = require('lodash');
var fs = require('fs');
var merge = require('merge2');
var path = require('path');
var constants_1 = require('./../constants');
var FileUtils_1 = require('./../utilities/FileUtils');
var os_1 = require('os');
var sp_module_interfaces_1 = require('@microsoft/sp-module-interfaces');
var manifestSchemaValidator_1 = require('@microsoft/sp-module-interfaces/lib/manifestSchemaValidator');
var OdspGulpTask_1 = require('./../OdspGulpTask');
var IsUrl_1 = require('./../utilities/IsUrl');
var cumulativeManifestProcessor_1 = require('./cumulativeManifest/cumulativeManifestProcessor');
var schemaPropertyName = '$schema';
/**
 * Writes a manifest for each entry in the project.
 *
 * Example:
 *  IN:
 *   the result of the prepareDeploy step enumerating each entry, each entry's dependencies, and a developer-generated
 *    base manifest for each entry.
 *
 *  OUT:
 *   a debug and, optionally, a production manifest for each entry.
 */
var WriteManifestsTask = (function (_super) {
    __extends(WriteManifestsTask, _super);
    function WriteManifestsTask() {
        _super.apply(this, arguments);
        this.name = 'writemanifests';
        this.taskConfig = {
            deployCdnPath: undefined,
            debugLocale: constants_1.default.defaultLocale,
            cdnUrlPrefix: undefined,
            cdnBasePath: undefined,
            shouldWrapProductionManifestForManifestServer: false,
            cumulativeManifestOptions: {
                ignoreOutputManifestIds: undefined
            }
        };
        // tslint:disable-next-line:no-any
        this._localizedResourcesCache = {};
    }
    /**
     * Normalizes a locale name. So "en-us" becomes "en-US" and "sr-cyrl-rs" becomes "sr-Cyrl-RS". There are two special
     *  cases. For pseudo-locales like "qps-ploc", everything stays lowecase. For language-script locales like "uz-Cyrl",
     *  only the script name's first character should be uppercased.
     */
    WriteManifestsTask.prototype.normalizeLocaleName = function (localeName) {
        localeName = localeName.toLowerCase();
        var localeTokens = localeName.split('-');
        if (localeTokens.length === 2) {
            var lastToken = localeTokens[1];
            if (lastToken.length === 2) {
                localeTokens[1] = lastToken.toUpperCase();
            }
            else if (lastToken === 'ploc' || lastToken === 'plocm' || lastToken === 'ploca') {
            }
            else {
                // The second token is the script token
                localeTokens[1] = this._uppercaseFirstLetter(lastToken);
            }
        }
        else if (localeTokens.length === 3) {
            var lastToken = localeTokens[2];
            if (lastToken.length === 2) {
                localeTokens[2] = lastToken.toUpperCase();
                localeTokens[1] = this._uppercaseFirstLetter(localeTokens[1]);
            }
            else {
                // The last token is the script token
                localeTokens[2] = this._uppercaseFirstLetter(lastToken);
                localeTokens[1] = localeTokens[1].toUpperCase();
            }
        }
        var normalizedLocale = localeTokens.join('-');
        return normalizedLocale;
    };
    WriteManifestsTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        if (!this.properties.deployEntries || this.properties.deployEntries.length === 0) {
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('No deploy entries specified. No manifests to write.');
            completeCallback();
            return;
        }
        var shouldProduceDebugManifests = !!this.taskConfig.debugBasePath;
        if (!this.taskConfig.debugBasePath) {
            this.logWarning('Debug base path not specified. Unable to produce debug manifests.');
        }
        var shouldProduceProductionManifests = this.buildConfig.production && !!this.taskConfig.cdnBasePath;
        if (this.buildConfig.production && !this.taskConfig.cdnBasePath) {
            this.logWarning('CDN base path not specified. Unable to produce production manifests.');
        }
        if (this.buildConfig.production && !this.taskConfig.deployCdnPath) {
            shouldProduceProductionManifests = false;
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('CDN deploy path not specified. Unable to produce production manifests.');
        }
        var debugManifests = [];
        var manifestIds = {};
        var tasks = [];
        this.properties.deployEntries.forEach(function (deployEntry) {
            if (!deployEntry.manifest) {
                _this.logWarning("Manifest not defined for entry \"" + deployEntry.entryName + "\".");
                return;
            }
            var validationResult = manifestSchemaValidator_1.default.validateManifest(JSON.stringify(deployEntry.manifest));
            if (!validationResult.result) {
                var errorText = manifestSchemaValidator_1.default.getFormattedErrorMessage(validationResult.errors);
                _this.logError("Manifest validation error (" + deployEntry.bundleEntry.manifest + "): " + os_1.EOL + errorText);
                return;
            }
            // Ensure we don't have a duplicate ID
            var lowercaseId = deployEntry.manifest.id.toLowerCase();
            if (lowercaseId in manifestIds) {
                /* tslint:disable:max-line-length */
                _this.logError("Duplicate manifest ID \"" + lowercaseId + "\". Exists in \"" + manifestIds[lowercaseId].bundleEntry.manifest + "\" and \"" + deployEntry.bundleEntry.manifest + "\".");
            }
            else {
                manifestIds[lowercaseId] = deployEntry;
            }
            _this._localizeManifest(deployEntry.manifest);
            if (shouldProduceDebugManifests) {
                var loaderConfig = _this._generateLoaderConfig(deployEntry.debugModules, [_this.taskConfig.debugBasePath], _this._resolveDebugPath.bind(_this), _this.taskConfig.debugLocale);
                var debugManifest = _this._generateManifest(deployEntry, loaderConfig);
                var isApplication = debugManifest.componentType === 'Application';
                if (isApplication) {
                    var preloadModules = _this._gatherPreloadManifestIds(deployEntry.debugModules);
                    _this._includePreloadManifestIds(preloadModules, debugManifest);
                }
                debugManifests.push(debugManifest);
                tasks.push(FileUtils_1.writeStringToFile(JSON.stringify(debugManifest, undefined, 2), debugManifest.id + ".manifest.json")
                    .pipe(gulp.dest(_this.buildConfig.distFolder)));
            }
            if (shouldProduceProductionManifests) {
                var loaderConfig = _this._generateLoaderConfig(deployEntry.productionModules, [_this.taskConfig.cdnBasePath], _this._resolveProductionPath.bind(_this));
                var productionManifest = _this._generateManifest(deployEntry, loaderConfig);
                if (productionManifest.componentType === 'Application') {
                    var preloadModules = _this._gatherPreloadManifestIds(deployEntry.productionModules);
                    _this._includePreloadManifestIds(preloadModules, productionManifest);
                }
                var cdnManifest = void 0;
                if (_this.taskConfig.shouldWrapProductionManifestForManifestServer) {
                    cdnManifest = {
                        ComponentType: productionManifest.componentType,
                        Id: productionManifest.id,
                        Manifest: JSON.stringify(productionManifest),
                        Name: productionManifest.id,
                        resources: {}
                    };
                }
                else {
                    cdnManifest = productionManifest;
                }
                tasks.push(FileUtils_1.writeStringToFile(JSON.stringify(cdnManifest), productionManifest.id + ".json")
                    .pipe(gulp.dest(_this.taskConfig.deployCdnPath)));
            }
        });
        if (shouldProduceDebugManifests) {
            var cumulativeManifestOptions = this.taskConfig.cumulativeManifestOptions;
            cumulativeManifestOptions.baseUrl = this.taskConfig.debugBasePath;
            var cumulativeManifestProcessor = new cumulativeManifestProcessor_1.default(cumulativeManifestOptions, this);
            tasks.push.apply(tasks, cumulativeManifestProcessor.generateCumulativeManifest(gulp, debugManifests));
        }
        return merge(tasks).on('finish', function () { return completeCallback(); });
    };
    /**
     * Localizes a manifest. Only works with WebPart and Application manifests,
     * otherwise it does nothing
     */
    WriteManifestsTask.prototype._localizeManifest = function (manifest) {
        switch (manifest.componentType) {
            case 'WebPart':
                // tslint:disable-next-line:no-any
                this._localizeWebPartManifest(manifest);
                break;
            case 'Application':
                this._localizeApplicationManifest(manifest);
                break;
        }
    };
    /**
     * Localizes a WebPart manifest. That includes title, description and group
     * for all preconfigured entries
     */
    // tslint:disable-next-line:no-any
    WriteManifestsTask.prototype._localizeWebPartManifest = function (manifest) {
        var _this = this;
        // tslint:disable-next-line:no-any
        manifest.preconfiguredEntries.forEach(function (entry) {
            entry.title = _this._localizeString(entry.title);
            entry.description = _this._localizeString(entry.description);
            if (entry.group) {
                entry.group = _this._localizeString(entry.group);
            }
        });
    };
    /**
     * Localizes an Application manifest. This includes title and description of the Application
     */
    WriteManifestsTask.prototype._localizeApplicationManifest = function (manifest) {
        manifest.title = this._localizeString(manifest.title);
        manifest.description = this._localizeString(manifest.description);
    };
    /**
     * Localizes a string with an id in the web $moduleName:expression;
     * If the string to localize is not based on an id, it returns the input param untouched.
     */
    WriteManifestsTask.prototype._localizeString = function (stringToLocalize) {
        // If there is no id, return early
        if (!stringToLocalize.id) {
            return stringToLocalize;
        }
        var regex = /^(?:\$)([^:]+)(?:\:)(.+)(?:\;)$/; // Test $<name>:<expr>;
        var matches = stringToLocalize.id.match(regex);
        if (matches && matches.length === 3) {
            this.logVerbose("Localizing string '" + matches[0] + "'");
            return this._localizeStringInternal(
            /* resourceName */ matches[1], 
            /* expression */ matches[2], 
            /* stringId */ matches[0]);
        }
        else {
            this.logError("String id '" + stringToLocalize.id + "' has wrong format. It is not $<moduleName>:<expression>;");
            // Return an empty ILocalizedString
            return {
                default: ''
            };
        }
    };
    /**
     * Localizes a string where it's been verified that the id follows the schema.
     * @param resourceName Name of the resource to load
     * @param expression Expression to be evaluated on the resource
     * @stringId Original id for the string. Used for logging purposes only
     * @returns Localized string with all found locales
     */
    WriteManifestsTask.prototype._localizeStringInternal = function (resourceName, expression, stringId) {
        var localizedString = {
            default: ''
        };
        var resources = this.properties.discoveredLocalizedResources[resourceName];
        if (resources) {
            for (var locale in resources) {
                // tslint:disable-next-line:no-any
                var resource = this._getResource(resources[locale]);
                var normalizedLocaleName = this.normalizeLocaleName(locale);
                if (resource) {
                    var evalString = expression.replace(resourceName, 'r');
                    var stringFromExpression = undefined;
                    try {
                        // We support any format for the localized resource,
                        // so we rely on the developer telling the code how to access it.
                        // Eval generates risk. In order to minimize it, only one expression is allowed.
                        // tslint:disable-next-line:no-eval
                        stringFromExpression = eval('function getLocalizedString(r) {' +
                            'return ' + evalString +
                            '}' +
                            'getLocalizedString(resource)');
                    }
                    catch (error) {
                        this.logWarning("Problem extracting id '" + stringId + "' in locale '" + normalizedLocaleName + "'");
                    }
                    if (stringFromExpression) {
                        localizedString[normalizedLocaleName] = stringFromExpression;
                    }
                    else {
                        this.logWarning("Couldn't find id '" + stringId + "' in locale '" + normalizedLocaleName + "'");
                    }
                }
            }
        }
        else {
            this.logError("Localized module '" + resourceName + "' not found");
        }
        return localizedString;
    };
    /**
     * Gets a resource file from a path.
     */
    // tslint:disable-next-line:no-any
    WriteManifestsTask.prototype._getResource = function (resourcePath) {
        if (!this._localizedResourcesCache[resourcePath]) {
            this._cacheResource(resourcePath);
        }
        return this._localizedResourcesCache[resourcePath];
    };
    /**
     * Caches a resource file from a path.
     * Because this execute in the build tools, function define is not defined,
     * so a fake function is created that will return the default element of the module.
     */
    /* tslint:disable:no-any */
    WriteManifestsTask.prototype._cacheResource = function (resourcePath) {
        // Fake a define method to get the localizedResource module
        // tslint:disable-next-line:no-unused-variable
        function define(name, deps, callback) {
            if (typeof name !== 'string') {
                callback = deps;
                deps = name;
                name = undefined;
            }
            if (!Array.isArray(deps)) {
                callback = deps;
                deps = undefined;
            }
            var exports = {};
            var result = callback([undefined, exports]);
            return result.default || result || exports.default;
        }
        try {
            // We can't get the localized module dynamically at this point.
            // Reading and executing the module file in order to get the module
            var resourcesFile = fs.readFileSync(resourcePath, 'utf8');
            // tslint:disable-next-line:no-eval
            var resource = eval(resourcesFile);
            this._localizedResourcesCache[resourcePath] = resource;
        }
        catch (error) {
            this.logError(("Can't get resource '" + resourcePath + "'. ") +
                "Check that the module is correct and has doesn't require any external module.");
        }
    };
    /* tslint:enable:no-any */
    WriteManifestsTask.prototype._gatherPreloadManifestIds = function (deployModules) {
        var preloadIds = [];
        if (deployModules.frameworkModules) {
            deployModules.frameworkModules.forEach(function (_, id) {
                var standardLibraryModule = sp_module_interfaces_1.standardLibraryModules[id];
                if (standardLibraryModule && standardLibraryModule.preloadId) {
                    preloadIds.push(standardLibraryModule.preloadId);
                    if (standardLibraryModule.dependentIds && standardLibraryModule.dependentIds.length) {
                        preloadIds.push.apply(preloadIds, standardLibraryModule.dependentIds);
                    }
                }
            });
        }
        return preloadIds;
    };
    WriteManifestsTask.prototype._includePreloadManifestIds = function (preloadIds, manifest) {
        if (!manifest.preloadComponents) {
            manifest.preloadComponents = [];
        }
        for (var _i = 0, preloadIds_1 = preloadIds; _i < preloadIds_1.length; _i++) {
            var preloadId = preloadIds_1[_i];
            if (manifest.preloadComponents.indexOf(preloadId) === -1) {
                manifest.preloadComponents.push(preloadId);
            }
        }
    };
    WriteManifestsTask.prototype._generateManifest = function (deployEntry, loaderConfig) {
        var manifest = lodash_1.cloneDeep(deployEntry.manifest);
        delete manifest[schemaPropertyName];
        manifest.loaderConfig = loaderConfig;
        return manifest;
    };
    WriteManifestsTask.prototype._generateLoaderConfig = function (deployModules, internalModuleBaseUrls, resolvePath, defaultLocaleOverride) {
        var _this = this;
        // Ensure all internalModuleBaseUrls have a trailing slash
        for (var i = 0; i < internalModuleBaseUrls.length; i++) {
            var internalModuleBaseUrl = internalModuleBaseUrls[i];
            if (!internalModuleBaseUrl.match(/\/$/)) {
                internalModuleBaseUrls[i] = internalModuleBaseUrl + "/";
            }
        }
        var scriptResources = {};
        if (deployModules.internalModules) {
            deployModules.internalModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'internal';
                scriptResources[id] = module;
                module.path = resolvePath(module.path);
            });
        }
        if (deployModules.localizedModules) {
            deployModules.localizedModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'localized';
                scriptResources[id] = module;
                var oldPaths = module.paths;
                module.paths = {};
                var lowercaseLocales = {};
                for (var locale in oldPaths) {
                    var path_1 = oldPaths[locale];
                    var lowercaseLocale = locale.toLowerCase();
                    var normalizedLocale = _this.normalizeLocaleName(lowercaseLocale);
                    lowercaseLocales[lowercaseLocale] = normalizedLocale;
                    module.paths[normalizedLocale] = resolvePath(path_1);
                }
                var lowercaseDefaultLocaleOverride = (defaultLocaleOverride && defaultLocaleOverride.toLowerCase)
                    ? defaultLocaleOverride.toLowerCase()
                    : undefined;
                if (lowercaseDefaultLocaleOverride && lowercaseDefaultLocaleOverride in lowercaseLocales) {
                    module.defaultPath = module.paths[lowercaseLocales[defaultLocaleOverride]];
                    delete module.paths;
                }
                else {
                    module.defaultPath = resolvePath(module.defaultPath);
                }
            });
        }
        if (deployModules.frameworkModules) {
            deployModules.frameworkModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'framework';
                scriptResources[id] = module;
                if (module.failoverPath) {
                    module.failoverPath = resolvePath(module.failoverPath);
                }
            });
        }
        if (!(deployModules.entryModuleId in scriptResources)) {
            this.logError(("Entry module \"" + deployModules.entryModuleId + "\" is missing a definition. The manifest will not ") +
                'load');
        }
        var result = {
            entryModuleId: deployModules.entryModuleId,
            internalModuleBaseUrls: internalModuleBaseUrls,
            scriptResources: scriptResources
        };
        return result;
    };
    WriteManifestsTask.prototype._resolveDebugPath = function (assetPath) {
        if (!assetPath) {
            return undefined;
        }
        if (typeof assetPath === 'string') {
            // If this is a full URL, don't change it
            if (IsUrl_1.default(assetPath)) {
                return assetPath;
            }
            else {
                return path.relative(this.buildConfig.rootPath, assetPath).replace(/\\/g, '/');
            }
        }
        else {
            return {
                default: this._resolveDebugPath(assetPath.default),
                debug: this._resolveDebugPath(assetPath.debug)
            };
        }
    };
    WriteManifestsTask.prototype._resolveProductionPath = function (assetPath) {
        if (!assetPath) {
            return undefined;
        }
        if (typeof assetPath === 'string') {
            var assetPathStr = assetPath;
            if (assetPathStr.charAt(0) === '/') {
                assetPathStr = assetPathStr.substr(1);
            }
            // If this is a full URL, don't change it
            if (IsUrl_1.default(assetPathStr)) {
                return assetPathStr;
            }
            else if (this.taskConfig.cdnUrlPrefix) {
                return path.posix.join(this.taskConfig.cdnUrlPrefix, assetPathStr);
            }
            else {
                return assetPathStr;
            }
        }
        else {
            return {
                default: this._resolveProductionPath(assetPath.default),
                debug: this._resolveProductionPath(assetPath.debug)
            };
        }
    };
    WriteManifestsTask.prototype._uppercaseFirstLetter = function (str) {
        return "" + str.slice(0, 1).toUpperCase() + str.slice(1);
    };
    return WriteManifestsTask;
}(OdspGulpTask_1.default));
exports.WriteManifestsTask = WriteManifestsTask;

//# sourceMappingURL=WriteManifestsTask.js.map
