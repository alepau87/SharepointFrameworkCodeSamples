"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var React = require('react');
var FocusZone_1 = require('office-ui-fabric-react/lib/FocusZone');
var sp_client_base_1 = require('@microsoft/sp-client-base');
var sp_client_base_2 = require('@microsoft/sp-client-base');
var Spinner_1 = require('office-ui-fabric-react/lib/Spinner');
var odsp_utilities_bundle_1 = require('@ms/odsp-utilities-bundle');
var CanvasControlType_1 = require('../../../canvas/canvas/CanvasControlType');
var ToolboxGroup_1 = require('../toolboxGroup/ToolboxGroup');
var ToolboxItem_1 = require('../toolboxItem/ToolboxItem');
var ToolboxItemClassifier_1 = require('../toolboxItem/ToolboxItemClassifier');
var CanvasA11y_1 = require('../../a11y/CanvasA11y');
require('./Toolbox.scss');
var CanvasStrings_resx_1 = require('../../loc/CanvasStrings.resx');
/**
 * @todo [VSO:SPPPlat] #231682
 */
var CLIENT_SIDE_TEAM_NEWS_FLIGHT = 953;
var NEWSFEED_ID = 'a5df8fdf-b508-4b66-98a6-d83bc2597f63';
var NEWSREEL_ID = '0ef418ba-5d19-4ade-9db0-b339873291d0';
var Toolbox = (function (_super) {
    __extends(Toolbox, _super);
    function Toolbox(props, context) {
        _super.call(this, props, context);
        this._handleKeyDownCapture = this._handleKeyDownCapture.bind(this);
        this.state = {
            verticalPosition: props.verticalPosition
        };
    }
    Toolbox.prototype.componentDidMount = function () {
        this._domNode.addEventListener('keydown', this._handleKeyDownCapture, true);
    };
    Toolbox.prototype.componentDidUpdate = function (prevProps) {
        if (this.props.isOpen !== prevProps.isOpen) {
            if (this.props.isOpen) {
                if (this.props.isLoading) {
                    this.context.store.a11yManager.ariaAlert(CanvasStrings_resx_1.default.ToolboxAriaLoadingAlert);
                }
                else {
                    /**
                     * Check to see if we're updating from the isLoading state by checking the previous
                     * props value. The current props only indicates if it is loading, whereas the transition
                     * from isLoading to not isLoading will indicate the particular render when loading has finished.
                     */
                    if (prevProps.isLoading) {
                        this.context.store.a11yManager.ariaAlert(CanvasStrings_resx_1.default.ToolboxAriaLoadingFinishedAlert);
                    }
                    this.context.store.a11yManager.saveState();
                    this.context.store.a11yManager.navigateTo(this._domNode);
                    // This assumes there is one non-webpart item (RTE)
                    var localizedItemCount = odsp_utilities_bundle_1.StringHelper.formatWithLocalizedCountValue(CanvasStrings_resx_1.default.CanvasItems, CanvasStrings_resx_1.default.CanvasItemsInterval, this.props.toolboxItems.length + 1);
                    var message = odsp_utilities_bundle_1.StringHelper.format(CanvasStrings_resx_1.default.ToolboxNavigationArrowKeys, localizedItemCount);
                    this.context.store.a11yManager.ariaAlert(message);
                }
            }
            else {
                this.context.store.a11yManager.clearState();
            }
        }
    };
    Toolbox.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.isOpen && this.context.store.scrollableParent) {
            // Use the scrollableParent as our viewport
            var _a = this.context.store.scrollableParent.getBoundingClientRect(), top_1 = _a.top, bottom = _a.bottom;
            // This value should be in sync with Toolbox.scss
            var toolboxHeight = 330;
            var canvasTop = this.context.store.canvasElement.getBoundingClientRect().top;
            var hintOffset = 28;
            var verticalPosition = nextProps.verticalPosition;
            // Render Toolbox above hint if there is no room below the hint and there is room above
            if ((verticalPosition + toolboxHeight + hintOffset + canvasTop > bottom) &&
                (verticalPosition - toolboxHeight - hintOffset > top_1)) {
                verticalPosition -= toolboxHeight + hintOffset;
            }
            this.setState({ verticalPosition: verticalPosition });
        }
    };
    Toolbox.prototype.render = function () {
        var _this = this;
        var _a = this.props, errorMessage = _a.errorMessage, isLoading = _a.isLoading, isOpen = _a.isOpen, onItemClick = _a.onItemClick, toolboxItems = _a.toolboxItems;
        var toolboxContent;
        if (isLoading) {
            toolboxContent = (React.createElement("div", {className: 'ms-Spinner-container'}, React.createElement(Spinner_1.Spinner, {type: Spinner_1.SpinnerType.large})));
        }
        else {
            // [VSO:SPPPlat #241904] Update the UI with design approved error state
            var errorLabel = void 0;
            if (errorMessage) {
                errorLabel = React.createElement("div", {className: 'CanvasToolbox-Error'}, " ", errorMessage, " ");
            }
            var classifier = new ToolboxItemClassifier_1.default();
            for (var _i = 0, toolboxItems_1 = toolboxItems; _i < toolboxItems_1.length; _i++) {
                var item = toolboxItems_1[_i];
                /* tslint:disable:no-any */
                var webPartManifest = item.itemProps.webPartManifest;
                /* tslint:enable:no-any */
                /**
                 * Component manifests will be sent to the client regardless of flight status.
                 * Currently checking the newsreel flight on client to hide the web part from the Toolbox
                 * if the flight is not on. @todo [VSO:SPPPlat] #231682
                 */
                if (!sp_client_base_2.SPFlight.isEnabled(CLIENT_SIDE_TEAM_NEWS_FLIGHT) &&
                    (webPartManifest.id === NEWSREEL_ID || webPartManifest.id === NEWSFEED_ID)) {
                    continue;
                }
                item.onClick = onItemClick;
                classifier.registerItem(item.key, item);
            }
            // Construct the featured toolbox group
            var featuredItemViews_1 = [];
            // First add the RTE to featured items
            featuredItemViews_1.push(React.createElement(ToolboxItem_1.default, {description: CanvasStrings_resx_1.default.TextWebpartDescription, displayName: CanvasStrings_resx_1.default.TextWebPartDisplayName, itemProps: { controlType: CanvasControlType_1.default.RTE, displayMode: sp_client_base_1.DisplayMode.Edit, id: undefined }, key: 0, msIconName: 'Font', onClick: onItemClick}));
            // next get the featured items and add them to the toolbox
            var featuredItemProps = classifier.classify(true);
            featuredItemProps.forEach(function (item) {
                featuredItemViews_1.push(React.createElement(ToolboxItem_1.default, __assign({}, item)));
            });
            // Add them to the featured group
            var featuredGroup = React.createElement(ToolboxGroup_1.default, {groupName: CanvasStrings_resx_1.default.ToolboxGroupNameFeatured, key: CanvasStrings_resx_1.default.ToolboxGroupNameFeatured, hasHeader: true}, featuredItemViews_1);
            // Construct the non featured toolbox group
            var nonFeaturedItemViews_1 = [];
            var nonFeaturedItemProps = classifier.classify(false, function (item1, item2) {
                return item1.displayName.localeCompare(item2.displayName);
            });
            nonFeaturedItemProps.forEach(function (item) {
                nonFeaturedItemViews_1.push(React.createElement(ToolboxItem_1.default, __assign({}, item)));
            });
            // Add them to the non featured group
            var nonFeaturedGroup = React.createElement(ToolboxGroup_1.default, {groupName: CanvasStrings_resx_1.default.ToolboxGroupNameNonFeatured, key: CanvasStrings_resx_1.default.ToolboxGroupNameNonFeatured, hasHeader: false}, nonFeaturedItemViews_1);
            toolboxContent = (React.createElement(FocusZone_1.FocusZone, {direction: FocusZone_1.FocusZoneDirection.horizontal, isCircularNavigation: true}, errorLabel, featuredGroup, nonFeaturedGroup));
        }
        return (React.createElement("div", {role: 'toolbar', className: 'CanvasToolbox', ref: function (ref) { return _this._domNode = ref; }, style: { display: isOpen ? 'block' : 'none', top: this.state.verticalPosition }}, toolboxContent));
    };
    Toolbox.prototype._handleKeyDownCapture = function (e) {
        if (CanvasA11y_1.isEscape(e)) {
            this.context.store.a11yManager.restoreState();
            this.context.store.closeToolbox();
            e.stopPropagation();
            e.preventDefault();
        }
        else if (CanvasA11y_1.isTab(e)) {
            e.stopPropagation();
            e.preventDefault();
        }
    };
    Toolbox.contextTypes = {
        store: React.PropTypes.object.isRequired
    };
    return Toolbox;
}(React.Component));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Toolbox;

//# sourceMappingURL=Toolbox.js.map
