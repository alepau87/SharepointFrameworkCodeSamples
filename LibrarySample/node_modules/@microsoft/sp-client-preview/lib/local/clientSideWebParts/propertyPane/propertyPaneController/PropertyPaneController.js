/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file  This file contains code to help control the web part PropertyPane
 */
'use strict';
var ReactDOM = require('react-dom');
var React = require('react');
var sp_client_base_1 = require('@microsoft/sp-client-base');
var PropertyPaneDefinitions_1 = require('../propertyPane/PropertyPaneDefinitions');
var PropertyPaneController_module_scss_1 = require('./PropertyPaneController.module.scss');
/**
 * This is to ensure we get the Strings as part of our bundle. As the webpack's require.ensure is not
 * recognizing the external module, referenced in the Strings. Hence, loading this module in the
 * base module which will internally load the external module, and make it available before the
 * require.ensure is called. Potential bug in webpack(VSO# 205556).
 */
require('../loc/Strings.resx');
/**
 * @todo: (SPPPLAT VSO#186293) After adding require.ensure for creating the PropertyPane async bundle,
 * this line is required because the PropertyPane depends on office-ui-react-fabric. This is a known
 * problem and will be investigated as a part of the bug mentioned above.
 */
require('office-ui-fabric-react');
/*
 * This class helps control the web part configuration PropertyPane. The web part framework comes with an inbuilt
 * PropertyPane. The web part developer should be able to use this PropertyPane with ease. Alternatively, the web part
 * developer can also create their own configuration pane if they do not like the functionality provided by the inbuilt
 * PropertyPane.
 */
var PropertyPaneController = (function () {
    /**
     * Instantiates the PropertyPaneController object.
     *
     * @param webPartGetter - delegate to get the web part.
     * @param callback - callback to be called when a configuration event happens.
     */
    function PropertyPaneController(webPartGetter, callback) {
        sp_client_base_1.Validate.isNotNullOrUndefined(webPartGetter, 'webPartGetter');
        this._webPartGetter = webPartGetter;
        this._configurationEventCallback = callback;
        // method bindings
        this._onPropertyChange = this._onPropertyChange.bind(this);
        this._onConfigurationEvent = this._onConfigurationEvent.bind(this);
        this._fireConfigurationEvent = this._fireConfigurationEvent.bind(this);
    }
    /**
     * Start configuring a web part. If the web part implements the configureStart API, this implies that the
     * web part wants to own its configuration experience.  If the web part does not implenent that API,
     * the inbuilt PropertyPane is used and there are the following conditions:
     *
     *   - propertyPaneState is Open and then open the PropertyPane.
     *   - propertyPaneState is Close and then close the PropertyPane.
     *   - propertyPaneState is Toggle and the PropertyPane is closed: in this case we open the PropertyPane and
     *       start the configuration process. This should happen on web part configure button being clicked.
     *   - propertyPaneState is Toggle and the PropertyPane is opened: in this case, if the web part id
     *       is that of a different web part than being currently configured, we keep the PropertyPane open
     *       and change the web part being configured.
     *   - propertyPaneState is Default and the PropertyPane is closed: do nothing
     *   - propertyPaneState is Default and the PropertyPane is opened: change the PropertyPane to display the
     *       settings of the newly selected web part. This should happen when the user navigates between web parts.
     *
     * @param id - instance id of the web part.
     * @param propertyPaneState - indicates in what state the PropertyPane should be.
     */
    PropertyPaneController.prototype.configureStart = function (id, propertyPaneState) {
        // 'id' can be 'undefined'. It happens when user selects RTE.
        // When 'id' is 'undefined' then 'wp' will be 'undefined'. In that case we render the empty PropertyPane.
        var toBeConfiguredWebPart = this._webPartGetter(id);
        this._resolvePropertyPaneElements();
        /**
         * A variable indicating, if the property pane will open or not. The flag is set to true when the pane is NOT
         * open and the requested propertyPaneState is either Open or Toggle.
         */
        var paneWillOpen = !this._isOpen &&
            (propertyPaneState === PropertyPaneDefinitions_1.PropertyPaneState.Open || propertyPaneState === PropertyPaneDefinitions_1.PropertyPaneState.Toggle);
        /**
         * Fire the 'PropertyPaneWebPartsSwitched' event on the new web part when web part switch happens or
         * for the existing web part before the property pane opens.
         */
        if (id && this._currentlyConfiguredWebPartId && (id !== this._currentlyConfiguredWebPartId || paneWillOpen)) {
            this._fireConfigurationEvent(id, PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneWebPartsSwitched);
        }
        this._configureStart(toBeConfiguredWebPart, id, propertyPaneState);
        this._currentlyConfiguredWebPartId = id;
    };
    /**
     * Make the PropertyPane disappear when the web part being configured is deleted from the page.
     *
     * @param id - Instance id of the web part.
     */
    PropertyPaneController.prototype.onWebPartDelete = function (id) {
        sp_client_base_1.Validate.isNonemptyString(id, 'id');
        if (id === this._currentlyConfiguredWebPartId) {
            if (this._isOpen) {
                this._renderPropertyPane(undefined, true);
            }
            this._currentlyConfiguredWebPartId = undefined;
        }
    };
    /**
     * Internal configure start.
     * @param wp - Web part to be configured.
     * @param id - Instance id of the web part to be configured.
     * @param propertyPaneState - State of the PropertyPane.
     */
    PropertyPaneController.prototype._configureStart = function (wp, id, propertyPaneState) {
        switch (propertyPaneState) {
            // PropertyPane should open.
            case PropertyPaneDefinitions_1.PropertyPaneState.Open:
                /**
                 * Inside the '_renderPropertyPane' the value of the variable '_isOpen' could be modified.
                 * Hence, to keep the before state of it, introducing 'paneOpenBeforeRender'.
                 */
                var paneOpenBeforeRender = this._isOpen;
                this._renderPropertyPane(wp, true, true);
                /**
                 * If pane is 'open' before '_renderPropertyPane' is called that means PropertyPane did not toggle.
                 * Hence no events were fired. So fire the events explicitly.
                 */
                if (paneOpenBeforeRender) {
                    this._fireNoToggleConfigurationEvents(id);
                }
                break;
            // PropertyPane should close.
            case PropertyPaneDefinitions_1.PropertyPaneState.Close:
                if (this._isOpen) {
                    this._renderPropertyPane(undefined);
                    this._togglePropertyPanePositionAndFireConfigurationEvents();
                }
                break;
            // PropertyPane should toggle i.e., if it's open, close it else open it.
            case PropertyPaneDefinitions_1.PropertyPaneState.Toggle:
                if (!this._isOpen) {
                    this._renderPropertyPane(wp, true, true);
                }
                else {
                    this._renderPropertyPane(undefined);
                    this._togglePropertyPanePositionAndFireConfigurationEvents();
                }
                break;
            // Keep the PropertyPane open if it's already open, else no-op.
            case PropertyPaneDefinitions_1.PropertyPaneState.Default:
                if (this._isOpen) {
                    // New web part triggered the 'configureStart' and the PropertyPane is open, so will keep it open.
                    // This results in NO toggle. So fire the events specific to this condition.
                    this._fireNoToggleConfigurationEvents(id);
                    if (this._isCurrentlyConfiguredPropertyPaneReactive) {
                        this._renderPropertyPane(wp, true, true);
                    }
                    else {
                        // TODO: (SPPPLAT VSO# Task 236141:Implement Non-Reactive PropertyPane in full).
                        // For now we are rendering the PropertyPane, but ideally we have to check if the
                        // PropertyPane is in dirty state and act accordingly.
                        this._renderPropertyPane(wp, true, true);
                    }
                }
                break;
        }
    };
    /**
     * Method to render the PropertyPane.
     *
     * @param currentWebpart - Current web part for which the PropertyPane is to be displayed.
     * @param shouldRecreatePropertyPaneElement - Indicating whether PropertyPane should be recreated or not.
     * @param resetPropertyPaneState - Indicating whether PropertyPane state should be reset.
     */
    PropertyPaneController.prototype._renderPropertyPane = function (currentWebpart, shouldRecreatePropertyPaneElement, resetPropertyPaneState) {
        var _this = this;
        // @todo: (SPPPLAT VSO#188120) Disabling for now due to webpack async loading bugs.
        // Load the PropertyPane asynchronously in a separate bundle.
        require.ensure([], function (require) {
            var propertyPane = require('../propertyPane/PropertyPane')['default'];
            _this._currentPropertyPaneData = currentWebpart ?
                currentWebpart._internalGetPropertyPaneSettings() : _this._getEmptyPropertyPaneData();
            // PropertyPane is rendered only when the web part supplies the settings for the
            // PropertyPane. If there are no settings to be displayed, we empty the PropertyPane
            // container and toggle back if the pane is already open.
            // We will re-visit this logic, once the decission is made, as to what to needs to be done.
            if (_this._currentPropertyPaneData) {
                // Only if this flag is true, re-insert the PropertyPane element into the DOM.
                var insertIntoDom = false;
                if (shouldRecreatePropertyPaneElement) {
                    // Recreating the PropertyPane. This will enable the PropertyPane to be in a valid state.
                    if (!_this._propertyPaneElement) {
                        _this._propertyPaneElement = document.createElement('div');
                        insertIntoDom = true;
                    }
                }
                if (currentWebpart) {
                    _this._propertyPaneElement.className = _this._currentPropertyPaneData.webPartId;
                    _this._currentPropertyPaneData.onPropertyChange = _this._onPropertyChange;
                    _this._currentPropertyPaneData.onConfigurationEvent = _this._onConfigurationEvent;
                    _this._currentPropertyPaneData.render = function () { _this._render(); };
                    _this._currentPropertyPaneData.shouldResetState = resetPropertyPaneState;
                }
                var el = React.createElement(propertyPane, { data: _this._currentPropertyPaneData });
                ReactDOM.render(el, _this._propertyPaneElement);
                // If the consumer app provides a container div, the PropertyPane will slide-in/out.
                // Else, the PropertyPane will be a popup and overlay over the content area.
                // Further, if not required, do not re-insert the element into dom.
                if (_this._propertyPaneContainer) {
                    if (insertIntoDom) {
                        _this._clearPropertyPaneContainer();
                        _this._propertyPaneContainer.appendChild(_this._propertyPaneElement);
                    }
                    if (!_this._isOpen) {
                        _this._togglePropertyPanePositionAndFireConfigurationEvents();
                    }
                }
                else {
                    if (insertIntoDom) {
                        document.body.insertBefore(_this._propertyPaneElement, document.body.lastChild.nextSibling);
                    }
                }
            }
        }, 'sp-client-preview-propertypane');
    };
    /**
     * Allow the PropertyPane to re-render itself. Used when navigating pages.
     */
    PropertyPaneController.prototype._render = function () {
        var wp = this._webPartGetter(this._currentPropertyPaneData.webPartId);
        if (wp) {
            this._renderPropertyPane(wp);
        }
    };
    /**
     * PropertyPane field change event handler.
     *
     * @param propertyName - Name of the PropertyPane field changed.
     * @param newValue - New value.
     */
    /* tslint:disable:no-any */
    PropertyPaneController.prototype._onPropertyChange = function (propertyName, newValue) {
        /* tslint:enable:no-any */
        sp_client_base_1.Validate.isNonemptyString(propertyName, 'propertyName');
        sp_client_base_1.Validate.isNotNullOrUndefined(newValue, 'newValue');
        if (!this._currentPropertyPaneData.webPartId) {
            throw new Error('onPropertyChange event is not expected when no web part is being configured');
        }
        var wp = this._webPartGetter(this._currentPropertyPaneData.webPartId);
        if (wp) {
            wp._internalOnPropertyChange(propertyName, newValue);
            this._renderPropertyPane(wp);
        }
        if (this._isCurrentlyConfiguredPropertyPaneReactive()) {
            this._resetConfigurationCompleteTimeout();
        }
    };
    /**
     * Callback to handle the configuration events that originate in the PropertyPane.
     * @example: PropertyPaneClosed, PropertyPaneApplyClicked etc.,
     */
    PropertyPaneController.prototype._onConfigurationEvent = function (configurationEvent) {
        switch (configurationEvent) {
            /**
             * For the event 'PropertyPaneClosed' we need to fire both the 'PropertyPaneClosed' and
             * 'PropertyPaneConfigurationComplete' events to the web part.
             * '_togglePropertyPanePosition' internally fires both the events.
             */
            case PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneClosed:
                this._togglePropertyPanePositionAndFireConfigurationEvents();
                break;
            /**
             * For these events we need to fire two events:
             *  - 'PropertyPaneConfigurationComplete' and
             *  - Whatever the event the caller has passed in 'configurationEvent'.
             */
            case PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneApplyClicked:
            case PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneLostFocus:
                this._fireConfigurationEvent(this._currentlyConfiguredWebPartId, configurationEvent);
                this._fireConfigurationEvent(this._currentlyConfiguredWebPartId, PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneConfigurationComplete);
                break;
        }
    };
    /**
     * Slide-in/out the PropertyPane
     */
    PropertyPaneController.prototype._togglePropertyPanePositionAndFireConfigurationEvents = function () {
        if (this._isOpen) {
            if (this._pageContentElement) {
                this._pageContentElement.classList.remove(PropertyPaneController_module_scss_1.default.shrinkContent);
            }
            else {
                /**
                 * If there is no page content element, then it means that it is classic page. So unmounting
                 * the PropertyPane node, because for some reason PropertyPane is not respecting PropertyPaneContainer
                 * styles.
                 *
                 *  This is a temporary fix, to unblock public preview. Permanent fix will be checked in soon.
                 * TODO: (SPPPLAT VSO: Bug 237945:Fix the PropertyPane rendering on the classic page)
                 */
                ReactDOM.unmountComponentAtNode(this._propertyPaneElement);
            }
            if (this._workbenchCommandBarElement) {
                this._workbenchCommandBarElement.classList.remove(PropertyPaneController_module_scss_1.default.shrinkContent);
            }
            this._propertyPaneContainer.classList.remove(PropertyPaneController_module_scss_1.default.showPane);
        }
        else {
            if (this._pageContentElement) {
                this._pageContentElement.classList.add(PropertyPaneController_module_scss_1.default.shrinkContent);
            }
            else {
                /**
                 * If there is no page content element, then it means that it is classic page. So unmounting
                 * the PropertyPane node, because for some reason PropertyPane is not respecting PropertyPaneContainer
                 * styles.
                 *
                 *  This is a temporary fix, to unblock public preview. Permanent fix will be checked in soon.
                 * TODO: (SPPPLAT VSO: Bug 237945:Fix the PropertyPane rendering on the classic page)
                 */
                this._propertyPaneContainer.style.top = '50px';
                this._propertyPaneContainer.style.zIndex = '999';
            }
            if (this._workbenchCommandBarElement) {
                this._workbenchCommandBarElement.classList.add(PropertyPaneController_module_scss_1.default.shrinkContent);
            }
            this._propertyPaneContainer.classList.add(PropertyPaneController_module_scss_1.default.showPane);
        }
        this._isOpen = !this._isOpen;
        // Fire the post toggle events.
        this._firePostToggleConfigurationEvents();
    };
    /**
     * Method to fire the configuration events post toggling the PropertyPane.
     * If toggling opened the PropertyPane then fire both the 'PropertyPaneOpened' and 'PropertyPaneConfigurationStart'
     * events after the ANIMATION_TIMEOUT is elapsed.
     * Else if the toggling resulted in closing the PropertyPane then fire 'PropertyPaneConfigurationComplete' event
     * and then after ANIMATION_TIMEOUT is elapsed fire 'PropertyPaneClosed' event.
     *
     * @private
     */
    PropertyPaneController.prototype._firePostToggleConfigurationEvents = function () {
        var _this = this;
        // @todo: this is a temporary fix to let the host (e.g. Canvas) know that the PropertyPane has completed
        // animating. The current PropertyPane animation is 367ms and hence the 400ms timeout. The correct fix is
        // to hookup to the animation end event.
        if (this._isOpen) {
            window.setTimeout(function () {
                _this._fireConfigurationEvent(_this._currentlyConfiguredWebPartId, PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneOpened);
                _this._fireConfigurationEvent(_this._currentlyConfiguredWebPartId, PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneConfigurationStart);
                /**
                 * Posting a message to the current window indicating that the property pane toggled.
                 * @example: Modern pages use this message to re-size it's header.'
                 */
                window.postMessage('Property pane toggled', window.location.origin);
            }, PropertyPaneController.ANIMATION_TIMEOUT);
        }
        else {
            this._fireConfigurationEvent(this._currentlyConfiguredWebPartId, PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneConfigurationComplete);
            window.setTimeout(function () {
                _this._fireConfigurationEvent(_this._currentlyConfiguredWebPartId, PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneClosed);
                /**
                 * Posting a message to the current window indicating that the property pane toggled.
                 * @example: Modern pages use this message to re-size it's header.'
                 */
                window.postMessage('Property pane toggled', window.location.origin);
            }, PropertyPaneController.ANIMATION_TIMEOUT);
        }
    };
    /**
     * Method to fire the configuration events when the PropertyPane did not toggle.
     * Fire the 'PropertyPaneConfigurationComplete' event on the current web part and
     * then 'PropertyPaneConfigurationStart' for the new web part.
     *
     * @private
     * @param id - Id of the web part to be configured.
     */
    PropertyPaneController.prototype._fireNoToggleConfigurationEvents = function (id) {
        // Firing events for the current web part.
        this._fireConfigurationEvent(this._currentlyConfiguredWebPartId, PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneConfigurationComplete);
        // Firing events for the new web part.
        this._fireConfigurationEvent(id, PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneConfigurationStart);
    };
    /**
     * Method to fire the configuration event to the host and the base web part.
     *
     * @param { webpartId } - Id of the web part to which the event needs to be sent.
     * @param { configurationEvent } - Kind of configuration event to fire.
     */
    PropertyPaneController.prototype._fireConfigurationEvent = function (webpartId, configurationEvent) {
        this._clearConfigurationCompleteTimeout();
        var wp = this._webPartGetter(webpartId);
        if (wp) {
            // Raise the event to the host.
            if (this._configurationEventCallback) {
                this._configurationEventCallback(configurationEvent, wp._internalSerialize());
            }
            // Raise the event to the web part.
            wp._internalOnConfigurationEvent(configurationEvent);
        }
    };
    /**
     * Private method to resolve the elements, which are used in slide in slide out effect.
     */
    PropertyPaneController.prototype._resolvePropertyPaneElements = function () {
        var workbenchElement = document.getElementById('workbenchPageContent');
        // TODO: (SPPPLAT VSO#222337) - Refactor Workbench page layout
        if (workbenchElement) {
            this._pageContentElement = workbenchElement;
            this._workbenchCommandBarElement = document.getElementById('workbenchCommandBar');
        }
        else {
            this._pageContentElement = document.getElementById('spPageChromeAppDiv');
        }
        // All modern apps should have the spPageChromeAppDiv. If not, then we should treat like the Classic page scenario.
        // i.e.the container div should be hanging off the root node. And we should create it only the first time.
        if (!this._pageContentElement) {
            if (!this._propertyPaneContainer) {
                this._propertyPaneContainer = document.createElement('div');
                this._propertyPaneContainer.id = PropertyPaneController.PROPERTY_PANE_CONTAINER_ID;
                this._propertyPaneContainer.className = PropertyPaneController.PROPERTY_PANE_CONTAINER_ID;
                document.body.appendChild(this._propertyPaneContainer);
            }
        }
        else {
            this._propertyPaneContainer = document.getElementById(PropertyPaneController.PROPERTY_PANE_CONTAINER_ID);
        }
    };
    /**
     * Removes all the children of the PropertyPane container.
     */
    PropertyPaneController.prototype._clearPropertyPaneContainer = function () {
        while (this._propertyPaneContainer && this._propertyPaneContainer.firstChild) {
            this._propertyPaneContainer.removeChild(this._propertyPaneContainer.firstChild);
        }
    };
    /**
     * Reset configuration completion timeout.
     */
    PropertyPaneController.prototype._resetConfigurationCompleteTimeout = function () {
        this._clearConfigurationCompleteTimeout();
        this._configurationCompletionTimeout = window.setTimeout(this._fireConfigurationEvent, PropertyPaneController.CONFIGURATION_COMPLETE_TIMEOUT, this._currentlyConfiguredWebPartId, PropertyPaneDefinitions_1.WebPartConfigurationEvent.PropertyPaneConfigurationComplete);
    };
    /**
     * Clear configuration completion timeout.
     */
    PropertyPaneController.prototype._clearConfigurationCompleteTimeout = function () {
        if (this._configurationCompletionTimeout) {
            window.clearTimeout(this._configurationCompletionTimeout);
            this._configurationCompletionTimeout = undefined;
        }
    };
    /**
     * Method to check whether the currently configured PropertyPane is reactive or not.
     */
    PropertyPaneController.prototype._isCurrentlyConfiguredPropertyPaneReactive = function () {
        if (this._currentlyConfiguredWebPartId) {
            var currentlyConfiguredWebPart = this._webPartGetter(this._currentlyConfiguredWebPartId);
            return currentlyConfiguredWebPart._internalGetPropertyPaneSettings().isReactive;
        }
        return false;
    };
    /**
     * Returns the PropertyPane data which has only 'onClose' defined. This is used when we have to display
     * empty property pane, when there is nothing to configure.
     */
    PropertyPaneController.prototype._getEmptyPropertyPaneData = function () {
        return {
            webPartId: undefined,
            title: undefined,
            shouldResetState: true,
            onPropertyChange: undefined,
            onConfigurationEvent: this._onConfigurationEvent,
            onRendered: undefined,
            properties: undefined,
            settings: undefined
        };
    };
    /**
     * PropertyPane animation timeout (in milliseconds).
     */
    PropertyPaneController.ANIMATION_TIMEOUT = 400;
    /**
     * PropertyPane configuration complete timeout for Reactive webparts (in milliseconds).
     */
    PropertyPaneController.CONFIGURATION_COMPLETE_TIMEOUT = 5000;
    /**
     * PropertyPane container id.
     */
    PropertyPaneController.PROPERTY_PANE_CONTAINER_ID = 'spPropertyPaneContainer';
    return PropertyPaneController;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PropertyPaneController;

//# sourceMappingURL=PropertyPaneController.js.map
