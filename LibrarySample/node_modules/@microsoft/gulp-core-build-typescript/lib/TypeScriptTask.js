"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var gulp_core_build_1 = require('@microsoft/gulp-core-build');
var ts = require('gulp-typescript');
var TypeScriptTask = (function (_super) {
    __extends(TypeScriptTask, _super);
    function TypeScriptTask() {
        var _this = this;
        _super.apply(this, arguments);
        this.name = 'typescript';
        this.taskConfig = {
            failBuildOnErrors: true,
            reporter: {
                error: function (error) {
                    var filename = error.relativeFilename || error.fullFilename;
                    var line = error.startPosition ? error.startPosition.line : 0;
                    var character = error.startPosition ? error.startPosition.character : 0;
                    var code = error.diagnostic.code;
                    var errorMessage = (typeof error.diagnostic.messageText === 'object') ?
                        error.diagnostic.messageText.messageText :
                        error.diagnostic.messageText;
                    _this.fileError(filename, line, character, 'TS' + code, errorMessage);
                }
            },
            sourceMatch: [
                'src/**/*.ts',
                'src/**/*.tsx',
                'typings/main/**/*.ts',
                'typings/main.d.ts',
                'typings/tsd.d.ts',
                'typings/index.d.ts'
            ],
            staticMatch: [
                'src/**/*.js',
                'src/**/*.json',
                'src/**/*.jsx'
            ]
        };
    }
    TypeScriptTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        /* tslint:disable:typedef */
        var plumber = require('gulp-plumber');
        var sourcemaps = require('gulp-sourcemaps');
        var assign = require('object-assign');
        var merge = require('merge2');
        /* tslint:enable:typedef */
        var errorCount = 0;
        var allStreams = [];
        var tsConfig = this.readJSONSync('tsconfig.json') || require('../tsconfig.json');
        // Log the compiler version for custom verisons.
        if (this.taskConfig.typescript && this.taskConfig.typescript.version) {
            this.log("Using custom version: " + this.taskConfig.typescript.version);
        }
        var tsCompilerOptions = assign({}, tsConfig.compilerOptions, {
            module: 'commonjs',
            sortOutput: true,
            typescript: this.taskConfig.typescript
        });
        var tsProject = this._tsProject = this._tsProject || ts.createProject(tsCompilerOptions);
        /* tslint:disable:typedef */
        var _a = this.buildConfig, libFolder = _a.libFolder, libAMDFolder = _a.libAMDFolder;
        /* tslint:enable:typedef */
        var tsResult = gulp.src(this.taskConfig.sourceMatch)
            .pipe(plumber({
            errorHandler: function () {
                errorCount++;
            }
        }))
            .pipe(sourcemaps.init())
            .pipe(ts(tsProject, undefined, this.taskConfig.reporter));
        allStreams.push(tsResult.js
            .pipe(sourcemaps.write('.', { sourceRoot: '/src' }))
            .pipe(gulp.dest(libFolder)));
        allStreams.push(tsResult.dts.pipe(gulp.dest(libFolder)));
        // Static passthrough files.
        var staticSrc = gulp.src(this.taskConfig.staticMatch);
        allStreams.push(staticSrc.pipe(gulp.dest(libFolder)));
        // If AMD modules are required, also build that.
        if (libAMDFolder) {
            allStreams.push(staticSrc.pipe(gulp.dest(libAMDFolder)));
            var tsAMDProject = ts.createProject(assign({}, tsCompilerOptions, { module: 'amd' }));
            tsResult = gulp.src(this.taskConfig.sourceMatch)
                .pipe(plumber({
                errorHandler: function () {
                    errorCount++;
                }
            }))
                .pipe(sourcemaps.write({ sourceRoot: '/src' }))
                .pipe(ts(tsAMDProject, undefined, this.taskConfig.reporter));
            allStreams.push(tsResult.js
                .pipe(sourcemaps.write('.', { sourceRoot: '/src' }))
                .pipe(gulp.dest(libAMDFolder)));
            allStreams.push(tsResult.dts.pipe(gulp.dest(libAMDFolder)));
        }
        // Listen for pass/fail, and ensure that the task passes/fails appropriately.
        merge(allStreams)
            .on('queueDrain', function () {
            if (_this.taskConfig.failBuildOnErrors && errorCount) {
                completeCallback('TypeScript error(s) occurred.');
            }
            else {
                completeCallback();
            }
        })
            .on('error', completeCallback);
    };
    /** Override the new mergeConfig API */
    TypeScriptTask.prototype.mergeConfig = function (config) {
        throw 'Do not use mergeConfig with gulp-core-build-typescript';
    };
    return TypeScriptTask;
}(gulp_core_build_1.GulpTask));
exports.TypeScriptTask = TypeScriptTask;

//# sourceMappingURL=TypeScriptTask.js.map
