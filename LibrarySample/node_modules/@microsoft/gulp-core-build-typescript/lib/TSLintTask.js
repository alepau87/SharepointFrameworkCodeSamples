"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var gulp_core_build_1 = require('@microsoft/gulp-core-build');
/* tslint:disable:typedef */
var cached = require('gulp-cache');
/* tslint:enable:typedef */
var through2 = require('through2');
var gutil = require('gulp-util');
var tslint = require('tslint');
var lodash_1 = require('lodash');
var md5 = require('md5');
var path = require('path');
var TSLintTask = (function (_super) {
    __extends(TSLintTask, _super);
    function TSLintTask() {
        var _this = this;
        _super.apply(this, arguments);
        this.name = 'tslint';
        this.taskConfig = {
            // lintConfig: require('../lib/defaultTslint.json'),
            lintConfig: {},
            reporter: function (result, file, options) {
                for (var _i = 0, _a = result.failures; _i < _a.length; _i++) {
                    var failure = _a[_i];
                    var pathFromRoot = path.relative(_this.buildConfig.rootPath, file.path);
                    var start = failure.getStartPosition().getLineAndCharacter();
                    if (_this.taskConfig.displayAsWarning) {
                        _this.fileWarning(pathFromRoot, start.line + 1, start.character + 1, failure.getRuleName(), failure.getFailure());
                    }
                    else {
                        _this.fileError(pathFromRoot, start.line + 1, start.character + 1, failure.getRuleName(), failure.getFailure());
                    }
                }
            },
            rulesDirectory: (function () {
                var msCustomRulesMain = require.resolve('tslint-microsoft-contrib');
                var msCustomRulesDirectory = path.dirname(msCustomRulesMain);
                return tslint.getRulesDirectories([msCustomRulesDirectory], __dirname);
            })(),
            sourceMatch: [
                'src/**/*.ts',
                'src/**/*.tsx'
            ],
            removeExistingRules: false,
            useDefaultConfigAsBase: true
        };
        /* tslint:disable:no-any */
        this._defaultLintRules = undefined;
    }
    /* tslint:enable:no-any */
    TSLintTask.prototype.setConfig = function (config) {
        // If the removeExistingRules flag is set, clear out any existing rules
        if (config.removeExistingRules &&
            this.taskConfig &&
            this.taskConfig.lintConfig) {
            delete this.taskConfig.lintConfig.rules;
            delete config.removeExistingRules;
        }
        _super.prototype.setConfig.call(this, config);
    };
    TSLintTask.prototype.executeTask = function (gulp) {
        var taskScope = this;
        var activeLintRules = taskScope._loadLintRules(); // tslint:disable-line:no-any
        return gulp.src(this.taskConfig.sourceMatch)
            .pipe(cached(through2.obj(function (file, encoding, callback) {
            taskScope.logVerbose(file.path);
            // Lint the file
            if (file.isNull()) {
                return callback(undefined, file);
            }
            // Stream is not supported
            if (file.isStream()) {
                this.emit('error', new gutil.PluginError(this.name, 'Streaming not supported'));
                return callback();
            }
            var options = {
                configuration: activeLintRules,
                formatter: 'json',
                formattersDirectory: undefined,
                rulesDirectory: taskScope.taskConfig.rulesDirectory || []
            };
            var tslintOutput = new tslint(file.relative, file.contents.toString('utf8'), options);
            /* tslint:disable:no-string-literal */
            var result = file['tslint'] = tslintOutput.lint();
            /* tslint:enable:no-string-literal */
            if (result.failureCount > 0) {
                taskScope.taskConfig.reporter(result, file, taskScope.taskConfig);
            }
            this.push(file);
            callback();
        }), {
            // Scope the cache to a combination of the lint rules and the build path
            name: md5(tslint.VERSION + JSON.stringify(activeLintRules) +
                taskScope.name + taskScope.buildConfig.rootPath),
            // What on the result indicates it was successful
            success: function (jshintedFile) {
                /* tslint:disable:no-string-literal */
                return jshintedFile['tslint'].failureCount === 0;
                /* tslint:enable:no-string-literal */
            },
            // By default, the cache attempts to store the value of the objects in the stream
            // For this task, this is over-engineering since we never need to store anything extra.
            value: function (file) {
                return {
                    path: file.path
                };
            }
        }));
    };
    TSLintTask.prototype._loadLintRules = function () {
        if (!this._defaultLintRules) {
            this._defaultLintRules = require('./defaultTslint.json');
        }
        return lodash_1.merge((this.taskConfig.useDefaultConfigAsBase ? this._defaultLintRules : {}), this.taskConfig.lintConfig || {});
    };
    return TSLintTask;
}(gulp_core_build_1.GulpTask));
exports.TSLintTask = TSLintTask;

//# sourceMappingURL=TSLintTask.js.map
